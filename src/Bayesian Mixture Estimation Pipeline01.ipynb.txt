{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "091e4546-865f-42b5-909b-d72361485867",
   "metadata": {},
   "source": [
    "### The goal is to estimate the proportion of DNA from two mitochondrial samples—Donor (D) and Recipient (R)—in a mixed sample (RDM), where the donor's contribution is very low (<2%). The method focuses on identifying and analyzing positions in the mitochondrial genome where the donor sample has unique homoplasmic variants compared to the recipient. By modeling the observed allele frequencies at these positions and accounting for sequencing errors, we can use Bayesian inference to estimate the donor's proportion in the mixture.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eff5b640-6df8-4404-af63-83a41640fa34",
   "metadata": {},
   "source": [
    "**Summary of the Steps:**\n",
    "\n",
    "1. **Identify Informative Positions**: Select positions in the mitochondrial genome where the donor sample (D) has unique homoplasmic alleles differing from the recipient sample (R).\n",
    "\n",
    "2. **Simulate Genomes and Sequencing Reads**:\n",
    "   - Generate synthetic mitochondrial genomes for R and D.\n",
    "   - Simulate sequencing reads for the mixed sample (RDM), combining R and D according to a known mixture proportion (e.g., <2%) and incorporating a sequencing error rate (e.g., 1%).\n",
    "\n",
    "3. **Model Observed Data**:\n",
    "   - At each informative position, model the number of reads supporting the D-specific allele using a binomial distribution.\n",
    "   - Calculate the expected allele frequency considering both the mixture proportion and sequencing errors.\n",
    "\n",
    "4. **Compute the Likelihood Function**:\n",
    "   - For different hypothetical mixture proportions \\( p \\), compute the likelihood of observing the data by summing log-likelihoods across all informative positions.\n",
    "\n",
    "5. **Perform Bayesian Inference**:\n",
    "   - Use a uniform prior over \\( p \\) (0% to 5%).\n",
    "   - Apply Bayes' theorem to obtain the posterior distribution of \\( p \\).\n",
    "   - Derive point estimates (mean, median, mode) and 95% credible intervals from the posterior.\n",
    "\n",
    "6. **Validate with Simulated Data**:\n",
    "   - Compare estimated mixture proportions to true values used in simulations.\n",
    "   - Assess accuracy, sensitivity, and robustness to sequencing errors.\n",
    "\n",
    "7. **Analyze Performance**:\n",
    "   - Visualize posterior distributions.\n",
    "   - Perform sensitivity analyses by varying parameters like sequencing depth and number of informative positions to evaluate the method's effectiveness.\n",
    "\n",
    "This streamlined approach focuses on detecting low-level mixtures by analyzing specific genomic positions and using Bayesian statistics to estimate mixture proportions accurately while accounting for sequencing errors."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "10666352-ccec-4fdb-848b-718259882aee",
   "metadata": {},
   "outputs": [],
   "source": [
    "##--------------------------------##\n",
    "##--------------------------------##"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7f4f5b70-715d-4af4-a92d-25227c0cf11c",
   "metadata": {},
   "source": [
    "**Summary of How the Method Works:**\n",
    "\n",
    "The method aims to accurately estimate the proportion of donor mitochondrial DNA (sample D) in a mixed sample (RDM) containing predominantly recipient DNA (sample R). It focuses on specific positions in the mitochondrial genome where the donor and recipient differ—these are called **informative positions**.\n",
    "\n",
    "1. **Identify Informative Positions**:\n",
    "   - Select positions where sample D has unique homoplasmic alleles that differ from those in sample R.\n",
    "   - These positions serve as markers to detect and quantify the presence of sample D in the mixture.\n",
    "\n",
    "2. **Model Expected Allele Frequencies**:\n",
    "   - For each informative position, calculate the expected frequency (\\( f_i \\)) of the D-specific allele in the mixed sample.\n",
    "   - This calculation accounts for both the true mixture proportion (\\( p \\)) and the sequencing error rate (\\( \\epsilon \\)):\n",
    "     \\[\n",
    "     f_i = p \\times (1 - \\epsilon) + (1 - p) \\times \\epsilon\n",
    "     \\]\n",
    "   - This formula reflects the probability of observing the D-specific allele from either true presence or sequencing errors.\n",
    "\n",
    "3. **Collect Observed Data**:\n",
    "   - Sequence the mixed sample (RDM) to obtain read data at each informative position.\n",
    "   - Record the number of reads supporting the D-specific allele (\\( k_i \\)) and the total number of reads (\\( n_i \\)) at each position.\n",
    "\n",
    "4. **Construct the Likelihood Function**:\n",
    "   - For each hypothetical mixture proportion \\( p \\) within the expected range (e.g., 0% to 5%), compute the likelihood of observing the data.\n",
    "   - Use the binomial probability mass function to model the likelihood at each position:\n",
    "     \\[\n",
    "     L_i(p) = \\binom{n_i}{k_i} f_i^{k_i} (1 - f_i)^{n_i - k_i}\n",
    "     \\]\n",
    "   - The overall likelihood is the product of individual likelihoods across all informative positions:\n",
    "     \\[\n",
    "     L(p) = \\prod_{i} L_i(p)\n",
    "     \\]\n",
    "\n",
    "5. **Perform Bayesian Inference**:\n",
    "   - **Specify a Prior**:\n",
    "     - Assume a uniform prior distribution for \\( p \\) between 0% and 5%, reflecting prior knowledge that the donor proportion is less than 2%.\n",
    "   - **Compute the Posterior Distribution**:\n",
    "     - Apply Bayes' theorem to update the prior belief based on the observed data:\n",
    "       \\[\n",
    "       P(p | \\text{data}) \\propto L(p) \\times P(p)\n",
    "       \\]\n",
    "     - Normalize the posterior distribution so that the total probability sums to 1.\n",
    "   - **Estimate the Mixture Proportion**:\n",
    "     - Derive point estimates of \\( p \\) (mean, median, mode) from the posterior distribution.\n",
    "     - Calculate credible intervals (e.g., 95% interval) to quantify uncertainty.\n",
    "\n",
    "6. **Estimate the Donor Proportion**:\n",
    "   - Use the posterior distribution to estimate the true mixture proportion of sample D in the mixed sample.\n",
    "   - Provide both point estimates and credible intervals to express confidence in the estimation.\n",
    "\n",
    "7. **Validation and Sensitivity Analysis**:\n",
    "   - **Simulate Data**:\n",
    "     - Create synthetic datasets with known mixture proportions and sequencing error rates to validate the method.\n",
    "   - **Assess Performance**:\n",
    "     - Compare estimated proportions to true values to evaluate accuracy.\n",
    "     - Perform sensitivity analyses by varying key parameters (e.g., sequencing depth, error rate, number of informative positions).\n",
    "     - Determine the method's robustness and the minimum detectable mixture ratio.\n",
    "\n",
    "**In Summary**:\n",
    "\n",
    "- The method leverages positions where the donor and recipient mitochondrial DNA differ to detect low levels of donor DNA in a mixture.\n",
    "- It models the expected frequency of the donor-specific alleles in the mixed sample, accounting for sequencing errors.\n",
    "- Bayesian inference is used to estimate the donor's mixture proportion, providing a probabilistic framework that incorporates prior knowledge and quantifies uncertainty.\n",
    "- Validation with simulated data ensures the method is accurate and robust, capable of detecting very low mixture proportions under realistic conditions.\n",
    "\n",
    "This approach allows for sensitive and accurate estimation of minor donor contributions in mitochondrial DNA mixtures, which is particularly useful in fields like forensic analysis, transplant monitoring, and studies of mitochondrial heteroplasmy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "26e71135-c94e-401f-be3f-dfe5a95b11b4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Bayesian Estimation of Mixture Ratios in Mitochondrial DNA Samples\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.stats import binom\n",
    "from scipy.interpolate import interp1d\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f41da611-7d26-438d-9554-cb380147f8e8",
   "metadata": {},
   "source": [
    "## Simulation of Mitochondrial Genomes for Samples R and D\n",
    "### Goal: Generate synthetic mitochondrial genomes for samples R and D, focusing on informative positions where they differ."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d2343e84-4dc7-4d7d-bcb1-fa8837d2f3d1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **1. Simulation of Mitochondrial Genomes for Samples R and D**\n",
    "\n",
    "# Parameters\n",
    "L = 16569          # Length of mitochondrial genome (human mtDNA)\n",
    "M = 50            # Number of informative positions (randomly selected)\n",
    "mean_depth = 800   # Mean sequencing depth\n",
    "epsilon = 0.02     # Sequencing error rate\n",
    "alleles = ['A', 'C', 'G', 'T']\n",
    "#np.random.seed(42) # For reproducibility\n",
    "\n",
    "# Generate informative positions (randomly selected from the full genome length L)\n",
    "positions = np.random.choice(np.arange(1, L+1), M, replace=False)  # Select M unique positions randomly\n",
    "\n",
    "# Assign alleles to sample R\n",
    "alleles_R = np.random.choice(alleles, M)\n",
    "\n",
    "# Assign different alleles to sample D at the same positions\n",
    "alleles_D = []\n",
    "for allele_R in alleles_R:\n",
    "    other_alleles = [a for a in alleles if a != allele_R]\n",
    "    allele_D = np.random.choice(other_alleles)\n",
    "    alleles_D.append(allele_D)\n",
    "alleles_D = np.array(alleles_D)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f9c62c88-f18f-4924-973b-9f62fe758472",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **2. Function to Simulate Sequencing Reads for Mixed Sample RDM**\n",
    "\n",
    "def simulate_reads(p_true, M, mean_depth, epsilon):\n",
    "    \"\"\"\n",
    "    Simulate sequencing reads for the mixed sample RDM at randomly selected informative positions.\n",
    "    \"\"\"\n",
    "    # Simulate total reads at each informative position\n",
    "    n_reads = np.random.poisson(lam=mean_depth, size=M)\n",
    "    \n",
    "    # Expected frequency of D-specific allele at each position\n",
    "    f_i = p_true * (1 - epsilon) + (1 - p_true) * epsilon\n",
    "    \n",
    "    # Simulate number of reads supporting D-specific allele at each position\n",
    "    k_reads = np.random.binomial(n_reads, f_i)\n",
    "    \n",
    "    return k_reads, n_reads, positions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4611b4d3-2433-4d16-b14d-0ef5947dfa86",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **3. Function to Compute Log Likelihood**\n",
    "\n",
    "def log_likelihood(p, k_reads, n_reads, epsilon):\n",
    "    \"\"\"\n",
    "    Compute the log likelihood of observing the data given mixture proportion p.\n",
    "    \"\"\"\n",
    "    f_i = p * (1 - epsilon) + (1 - p) * epsilon\n",
    "    f_i = np.clip(f_i, 1e-10, 1 - 1e-10)  # Avoid log(0)\n",
    "    log_L_i = binom.logpmf(k_reads, n_reads, f_i)\n",
    "    log_L = np.sum(log_L_i)\n",
    "    return log_L"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "11fa5f13-26f6-4483-aa1c-45d5b05bd54b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **4. Function to Perform Bayesian Inference**\n",
    "\n",
    "def bayesian_estimation(k_reads, n_reads, epsilon):\n",
    "    \"\"\"\n",
    "    Perform Bayesian estimation of the mixture proportion p.\n",
    "    \"\"\"\n",
    "    # Define a grid of p values\n",
    "    p_grid = np.linspace(0, 0.05, 4000)\n",
    "    \n",
    "    # Compute log likelihood for each p\n",
    "    log_L_values = np.array([log_likelihood(p, k_reads, n_reads, epsilon) for p in p_grid])\n",
    "    \n",
    "    # Convert log likelihoods to likelihoods\n",
    "    L_values = np.exp(log_L_values - np.max(log_L_values))  # For numerical stability\n",
    "    \n",
    "    # Assume a uniform prior over p (from 0% to 5%)\n",
    "    posterior = L_values / np.sum(L_values)\n",
    "    \n",
    "    # Compute estimates\n",
    "    p_est_mean = np.sum(p_grid * posterior)\n",
    "    cumulative_posterior = np.cumsum(posterior)\n",
    "    interp_cdf = interp1d(cumulative_posterior, p_grid)\n",
    "    p_est_median = interp_cdf(0.5)\n",
    "    p_est_mode = p_grid[np.argmax(posterior)]\n",
    "    lower_bound = interp_cdf(0.025)\n",
    "    upper_bound = interp_cdf(0.975)\n",
    "\n",
    "    #change CI values if you get error:\n",
    "    #for example for 90% confidence interval:\n",
    "    #lower_bound = interp_cdf(0.005)\n",
    "    #upper_bound = interp_cdf(0.995)\n",
    "    \n",
    "    return {\n",
    "        'p_grid': p_grid,\n",
    "        'posterior': posterior,\n",
    "        'p_est_mean': p_est_mean,\n",
    "        'p_est_median': p_est_median,\n",
    "        'p_est_mode': p_est_mode,\n",
    "        'lower_bound': lower_bound,\n",
    "        'upper_bound': upper_bound\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3295ee3e-24e8-4e0a-95d9-cc804395837f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **5. Simulation and Estimation Function**\n",
    "\n",
    "def simulate_and_estimate(p_true, M, mean_depth, epsilon):\n",
    "    \"\"\"\n",
    "    Simulate data and estimate the mixture proportion p.\n",
    "    \"\"\"\n",
    "    # Simulate sequencing reads\n",
    "    k_reads, n_reads, positions = simulate_reads(p_true, M, mean_depth, epsilon)\n",
    "    \n",
    "    # Perform Bayesian estimation\n",
    "    estimation_results = bayesian_estimation(k_reads, n_reads, epsilon)\n",
    "    \n",
    "    # Include true p in results\n",
    "    estimation_results['p_true'] = p_true\n",
    "    return estimation_results\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dad65509-05a5-4a2e-9e55-037648d121b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **6. Validation with Simulated Data**\n",
    "\n",
    "# Test mixture proportions\n",
    "p_true_values = [0.001, 0.005, 0.01, 0.02]\n",
    "\n",
    "# Collect results\n",
    "results_list = []\n",
    "\n",
    "for p_true in p_true_values:\n",
    "    results = simulate_and_estimate(p_true, M, mean_depth, epsilon)\n",
    "    results_list.append(results)\n",
    "    print(f\"True proportion: {p_true*100:.2f}%\")\n",
    "    print(f\"Estimated proportion (mean): {results['p_est_mean']*100:.4f}%\")\n",
    "    print(f\"Estimated proportion (median): {results['p_est_median']*100:.4f}%\")\n",
    "    print(f\"Estimated proportion (mode): {results['p_est_mode']*100:.4f}%\")\n",
    "    print(f\"95% Credible Interval: [{results['lower_bound']*100:.4f}%, {results['upper_bound']*100:.4f}%]\")\n",
    "    print(\"-\" * 50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d715c26d-552e-4ed1-b493-d9b871df2976",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "\n",
    "def plot_posterior_distribution(results_list):\n",
    "    \"\"\"\n",
    "    Plot the posterior distributions of p for different true mixture proportions,\n",
    "    with a dashed line indicating the true p-value on the x-axis.\n",
    "    \n",
    "    Args:\n",
    "    results_list (list): A list of result dictionaries from simulate_and_estimate(),\n",
    "                         where each dictionary contains the posterior distribution\n",
    "                         and the true p-value ('p_true').\n",
    "    \"\"\"\n",
    "    plt.figure(figsize=(12, 8))\n",
    "\n",
    "    for results in results_list:\n",
    "        # Plot the posterior distribution\n",
    "        plt.plot(results['p_grid']*100, results['posterior'], label=f\"True p = {results['p_true']*100:.2f}%\", alpha=0.7)\n",
    "\n",
    "        # Add a dashed line for the true p value on the x-axis\n",
    "        plt.axvline(results['p_true']*100, color='black', linestyle='--', label=f'True p = {results[\"p_true\"]*100:.2f}%')\n",
    "    \n",
    "    plt.xlabel('Mixture Proportion p (%)')\n",
    "    plt.ylabel('Posterior Probability')\n",
    "    plt.title('Posterior Distributions for Different True Mixture Proportions')\n",
    "    plt.legend()\n",
    "    plt.grid(True)\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "\n",
    "#Assuming `results_list` is a list of results from the simulate_and_estimate function\n",
    "plot_posterior_distribution(results_list)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a05a8384-1295-49b9-b6a1-cd6666ba1718",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **8. Performance Evaluation**\n",
    "\n",
    "# Extract true and estimated p values\n",
    "true_p_values = [res['p_true'] for res in results_list]\n",
    "estimated_p_means = [res['p_est_mean'] for res in results_list]\n",
    "estimated_p_medians = [res['p_est_median'] for res in results_list]\n",
    "estimated_p_modes = [res['p_est_mode'] for res in results_list]\n",
    "\n",
    "# Plot True vs. Estimated p\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(np.array(true_p_values)*100, np.array(estimated_p_means)*100, 'o-', label='Estimated p (Mean)')\n",
    "plt.plot(np.array(true_p_values)*100, np.array(estimated_p_medians)*100, 's--', label='Estimated p (Median)')\n",
    "plt.plot(np.array(true_p_values)*100, np.array(estimated_p_modes)*100, 'd:', label='Estimated p (Mode)')\n",
    "plt.plot([0, 2], [0, 2], 'k--', label='Ideal')\n",
    "plt.xlabel('True Mixture Proportion p (%)')\n",
    "plt.ylabel('Estimated Mixture Proportion p (%)')\n",
    "plt.title('True vs. Estimated Mixture Proportions')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "de600ab8-0d47-4900-8d26-863b0167aa34",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **9. Sensitivity Analysis**\n",
    "\n",
    "# Vary sequencing depth\n",
    "depth_values = [100, 200, 400, 800]\n",
    "p_true = 0.005  # Fixed true p at 0.5%\n",
    "results_depth = []\n",
    "\n",
    "for depth in depth_values:\n",
    "    results = simulate_and_estimate(p_true, M, depth, epsilon)\n",
    "    results_depth.append(results)\n",
    "    print(f\"Sequencing Depth: {depth}x\")\n",
    "    print(f\"Estimated p (mean): {results['p_est_mean']*100:.4f}%\")\n",
    "    print(f\"95% Credible Interval: [{results['lower_bound']*100:.4f}%, {results['upper_bound']*100:.4f}%]\")\n",
    "    print(\"-\" * 50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aabd8d79-f0c5-4e2a-827d-e67cce820031",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Example usage:\n",
    "p_true = 0.01  # True mixture proportion\n",
    "k_reads, n_reads, positions = simulate_reads(p_true, M, mean_depth, epsilon)\n",
    "inspect_simulated_data(k_reads, n_reads, positions, epsilon)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "66e1b921-b5e7-49a7-a73c-518c42f9a3eb",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
